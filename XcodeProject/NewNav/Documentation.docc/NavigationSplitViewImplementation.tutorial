@Tutorial(time: 25) {
    @Intro(title: "Build a three-column experience") {
        Learn how to embed your SwiftUI views inside `NavigationSplitView` and keep selections synchronized across sidebar, content, and inspector columns. Follow along with the sample project in this repository to produce a responsive UI that works on iPadOS, macOS, and iOS.
    }

    @Section(title: "Prepare the data model") {
        @ContentAndMedia {
            Start with lightweight data structures that are easy to present inside SwiftUI. Identifiable models make it trivial to bind selections to the split view columns.
        }

        @Steps {
            @Step {
                Define an identifiable model that represents the items you want to browse, for example the `CustomColor` and `CustomColorCategory` types from the sample project. Include stable identifiers so SwiftUI can diff list rows.

                @Code(name: "CustomColor.swift", file: "data-model.swift")
            }

            @Step {
                Provide a collection of sample data so the view hierarchy can populate the sidebar and detail panes during development. Keep it in memory (like `Data.categories`) until you connect a real data source.

                @Code(name: "Data.swift", file: "sample-data.swift")
            }

            @Step {
                Store the selection in state (`@State private var selectedColor: CustomColor?`) or pass bindings down to child views. `NavigationSplitView` updates these bindings automatically as the user interacts with the UI.

                @Code(name: "ContentView.swift", file: "selection-state.swift")
            }
        }
    }

    @Section(title: "Compose the split view") {
        @ContentAndMedia {
            `NavigationSplitView` renders up to three columns. You decide how to populate each closure and when to surface optional surfaces like the inspector.
        }

        @Steps {
            @Step {
                Wrap the navigation columns in `NavigationSplitView(columnVisibility:)` and use a `List(categories, selection: $selectedCategory)` inside the sidebar closure so users can pick a category.

                @Code(name: "ContentView.swift", file: "split-view-layout.swift")
            }

            @Step {
                Present the focused content in the detail area. A container view such as `DetailView` can unwrap the optional selection and either render the chosen item or display a placeholder.

                @Code(name: "DetailView.swift", file: "detail-view.swift")
            }

            @Step {
                Add an inspector column when you have secondary information, such as metadata, tags, or change history. Pass the view through the `inspector` parameter and toggle its visibility with a `@State` binding.

                @Code(name: "ContentView.swift", file: "inspector-panel.swift")
            }
        }
    }

    @Section(title: "Refine platform behavior") {
        @ContentAndMedia {
            Size classes and column visibility controls let you tailor the experience to each platform without creating separate screens.
        }

        @Steps {
            @Step {
                Constrain column visibility with `NavigationSplitViewVisibility` to keep the interface comfortable on iPhone. Clamp to `.doubleColumn` or `.all` on wider devices and fall back to `.automatic` when space is tight.

                @Code(name: "ContentView.swift", file: "column-visibility.swift")
            }

            @Step {
                Observe `horizontalSizeClass` and respond to changes with modifiers like `onAppear` and `onChange`. Update inspector visibility or selected items when the size class changes.

                @Code(name: "ContentView.swift", file: "size-class-handling.swift")
            }

            @Step {
                Connect additional UI state (toolbars, inspectors, preview panes) to the same bindings so the experience stays synchronized even when the user opens multiple windows or rotates their device.

                @Code(name: "ContentView.swift", file: "selection-sync.swift")
            }
        }
    }

    @Section(title: "Next steps") {
        @ContentAndMedia {
            Expand the pattern with deep-link navigation paths, multi-selection sidebars, or custom inspectors that expose editing controls.
        }

        @Steps {
            @Step {
                Identify the parts of your own project that can reuse the sample views, then extract the shared state into an observable object or navigation model so multiple windows stay in sync.

                @Code(name: "NavigationModel.swift", file: "shared-navigation-model.swift")
            }

            @Step {
                Inject the navigation model into the split view and derive bindings so every column, detail view, and inspector stays synchronized across windows.

                @Code(name: "AppContentView.swift", file: "navigation-model-integration.swift")
            }
        }
    }
}
